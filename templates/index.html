<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Demo - keras-ocr vs docTR</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="/" class="nav-logo">OCR Demo</a>
            <ul class="nav-menu">
                <li><a href="/" class="nav-link active">Demo</a></li>
                <li><a href="/about" class="nav-link">About & Technologies</a></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <header>
            <h1>Image Text Recognition Demo</h1>
            <p class="subtitle">Compare OCR results: <strong>keras-ocr</strong> vs <strong>docTR</strong> vs <strong>Tesseract</strong> vs <strong>PaddleOCR</strong></p>
        </header>

        <main>
            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                    </div>
                    <p class="upload-text">Drag and drop an image here</p>
                    <p class="upload-or">or</p>
                    <label class="upload-button">
                        Browse Files
                        <input type="file" id="fileInput" accept="image/*" hidden>
                    </label>
                    <p class="upload-hint">Supports PNG, JPG, GIF, BMP, TIFF, WebP (max 16MB)</p>
                </div>

                <div class="preview-section" id="previewSection" style="display: none;">
                    <div style="width:100%">
                        <img id="imagePreview" src="" alt="Preview">
                    </div>
                    <button class="clear-button" id="clearButton">Clear & Try Another</button>
                </div>
            </div>

            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <p>Processing with 4 OCR engines...</p>
            </div>

            <div class="error-message" id="errorMessage" style="display: none;">
                <p id="errorText"></p>
            </div>

            <div class="results-comparison" id="resultsSection" style="display: none;">
                <h2>OCR Results Comparison (4 Engines)</h2>
                <div class="comparison-grid four-col">
                    <!-- keras-ocr -->
                    <div class="result-card keras">
                        <div class="result-header">
                            <h3>keras-ocr</h3>
                            <span class="badge scene-text">Scene Text</span>
                        </div>
                        <div class="result-meta">
                            <span>CRAFT + CRNN | TensorFlow</span>
                        </div>
                        <div class="result-box">
                            <pre id="kerasResult"></pre>
                        </div>
                        <div class="result-analysis" id="kerasAnalysis">
                            <div class="analysis-header">Analysis</div>
                            <div class="analysis-grid">
                                <div class="analysis-item">
                                    <span class="analysis-label">Time</span>
                                    <span class="analysis-value" id="kerasTime">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Words</span>
                                    <span class="analysis-value" id="kerasWords">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Lines</span>
                                    <span class="analysis-value" id="kerasLines">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Chars</span>
                                    <span class="analysis-value" id="kerasChars">-</span>
                                </div>
                            </div>
                            <div class="analysis-features">
                                <span class="feature-tag" id="kerasUppercase">A-Z</span>
                                <span class="feature-tag" id="kerasNumbers">0-9</span>
                                <span class="feature-tag" id="kerasSymbols">!@#</span>
                            </div>
                        </div>
                        <button class="copy-button" onclick="copyText('kerasResult')">Copy</button>
                    </div>

                    <!-- docTR -->
                    <div class="result-card doctr">
                        <div class="result-header">
                            <h3>docTR</h3>
                            <span class="badge document">Document</span>
                        </div>
                        <div class="result-meta">
                            <span>DBNet + CRNN | TensorFlow</span>
                        </div>
                        <div class="result-box">
                            <pre id="doctrResult"></pre>
                        </div>
                        <div class="result-analysis" id="doctrAnalysis">
                            <div class="analysis-header">Analysis</div>
                            <div class="analysis-grid">
                                <div class="analysis-item">
                                    <span class="analysis-label">Time</span>
                                    <span class="analysis-value" id="doctrTime">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Words</span>
                                    <span class="analysis-value" id="doctrWords">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Lines</span>
                                    <span class="analysis-value" id="doctrLines">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Confidence</span>
                                    <span class="analysis-value" id="doctrConfidence">-</span>
                                </div>
                            </div>
                            <div class="analysis-features">
                                <span class="feature-tag" id="doctrUppercase">A-Z</span>
                                <span class="feature-tag" id="doctrNumbers">0-9</span>
                                <span class="feature-tag" id="doctrSymbols">!@#</span>
                            </div>
                        </div>
                        <button class="copy-button" onclick="copyText('doctrResult')">Copy</button>
                    </div>

                    <!-- Tesseract -->
                    <div class="result-card tesseract">
                        <div class="result-header">
                            <h3>Tesseract</h3>
                            <span class="badge classic">Classic OCR</span>
                        </div>
                        <div class="result-meta">
                            <span>Google Tesseract | Rule-based</span>
                        </div>
                        <div class="result-box">
                            <pre id="tesseractResult"></pre>
                        </div>
                        <div class="result-analysis" id="tesseractAnalysis">
                            <div class="analysis-header">Analysis</div>
                            <div class="analysis-grid">
                                <div class="analysis-item">
                                    <span class="analysis-label">Time</span>
                                    <span class="analysis-value" id="tesseractTime">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Words</span>
                                    <span class="analysis-value" id="tesseractWords">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Lines</span>
                                    <span class="analysis-value" id="tesseractLines">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Confidence</span>
                                    <span class="analysis-value" id="tesseractConfidence">-</span>
                                </div>
                            </div>
                            <div class="analysis-features">
                                <span class="feature-tag" id="tesseractUppercase">A-Z</span>
                                <span class="feature-tag" id="tesseractNumbers">0-9</span>
                                <span class="feature-tag" id="tesseractSymbols">!@#</span>
                            </div>
                        </div>
                        <button class="copy-button" onclick="copyText('tesseractResult')">Copy</button>
                    </div>

                    <!-- PaddleOCR -->
                    <div class="result-card paddleocr">
                        <div class="result-header">
                            <h3>PaddleOCR</h3>
                            <span class="badge multilang">Multi-language</span>
                        </div>
                        <div class="result-meta">
                            <span>PP-OCR | PaddlePaddle</span>
                        </div>
                        <div class="result-box">
                            <pre id="paddleocrResult"></pre>
                        </div>
                        <div class="result-analysis" id="paddleocrAnalysis">
                            <div class="analysis-header">Analysis</div>
                            <div class="analysis-grid">
                                <div class="analysis-item">
                                    <span class="analysis-label">Time</span>
                                    <span class="analysis-value" id="paddleocrTime">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Words</span>
                                    <span class="analysis-value" id="paddleocrWords">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Lines</span>
                                    <span class="analysis-value" id="paddleocrLines">-</span>
                                </div>
                                <div class="analysis-item">
                                    <span class="analysis-label">Confidence</span>
                                    <span class="analysis-value" id="paddleocrConfidence">-</span>
                                </div>
                            </div>
                            <div class="analysis-features">
                                <span class="feature-tag" id="paddleocrUppercase">A-Z</span>
                                <span class="feature-tag" id="paddleocrNumbers">0-9</span>
                                <span class="feature-tag" id="paddleocrSymbols">!@#</span>
                            </div>
                        </div>
                        <button class="copy-button" onclick="copyText('paddleocrResult')">Copy</button>
                    </div>
                </div>

                <div class="comparison-notes">
                    <h3>Key Differences</h3>
                    <div class="notes-grid four-col">
                        <div class="note keras">
                            <strong>keras-ocr:</strong> Lowercase only, scene text optimized
                        </div>
                        <div class="note doctr">
                            <strong>docTR:</strong> Preserves case, document optimized
                        </div>
                        <div class="note tesseract">
                            <strong>Tesseract:</strong> Classic OCR, fast, 100+ languages
                        </div>
                        <div class="note paddleocr">
                            <strong>PaddleOCR:</strong> Chinese-optimized, high accuracy
                        </div>
                    </div>
                </div>

                <!-- Comparison Chart -->
                <div class="chart-section" id="chartSection">
                    <h3>Performance Comparison Chart</h3>
                    <div class="canvas-chart-container">
                        <canvas id="comparisonChart" width="800" height="350"></canvas>
                    </div>
                    <div class="chart-legend">
                        <div class="legend-item">
                            <div class="legend-color keras"></div>
                            <span>keras-ocr</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color doctr"></div>
                            <span>docTR</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color tesseract"></div>
                            <span>Tesseract</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color paddleocr"></div>
                            <span>PaddleOCR</span>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <footer class="about-footer">
            <p>Built with TensorFlow, PaddlePaddle, Tesseract, Flask</p>
            <p>&copy; Copyright 2026 by <a href="https://github.com/apollosoftdev" target="_blank">ApexSpire</a></p>
        </footer>
    </div>

    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previewSection = document.getElementById('previewSection');
        const imagePreview = document.getElementById('imagePreview');
        const clearButton = document.getElementById('clearButton');
        const resultsSection = document.getElementById('resultsSection');
        const kerasResult = document.getElementById('kerasResult');
        const doctrResult = document.getElementById('doctrResult');
        const tesseractResult = document.getElementById('tesseractResult');
        const paddleocrResult = document.getElementById('paddleocrResult');
        const loading = document.getElementById('loading');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        clearButton.addEventListener('click', resetUI);

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showError('Please select an image file.');
                return;
            }

            if (file.size > 16 * 1024 * 1024) {
                showError('File size must be less than 16MB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                uploadArea.style.display = 'none';
                previewSection.style.display = 'block';
            };
            reader.readAsDataURL(file);

            uploadImage(file);
        }

        function uploadImage(file) {
            const formData = new FormData();
            formData.append('file', file);

            loading.style.display = 'flex';
            resultsSection.style.display = 'none';
            errorMessage.style.display = 'none';

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                loading.style.display = 'none';

                if (data.error) {
                    showError(data.error);
                } else {
                    // Set text results
                    kerasResult.textContent = data.keras_ocr.text;
                    doctrResult.textContent = data.doctr.text;
                    tesseractResult.textContent = data.tesseract.text;
                    paddleocrResult.textContent = data.paddleocr.text;

                    // Set keras-ocr analysis
                    document.getElementById('kerasTime').textContent = data.keras_ocr.processing_time_ms + ' ms';
                    document.getElementById('kerasWords').textContent = data.keras_ocr.word_count;
                    document.getElementById('kerasLines').textContent = data.keras_ocr.line_count;
                    document.getElementById('kerasChars').textContent = data.keras_ocr.char_count;
                    updateFeatureTag('kerasUppercase', data.keras_ocr.has_uppercase);
                    updateFeatureTag('kerasNumbers', data.keras_ocr.has_numbers);
                    updateFeatureTag('kerasSymbols', data.keras_ocr.has_symbols);

                    // Set docTR analysis
                    document.getElementById('doctrTime').textContent = data.doctr.processing_time_ms + ' ms';
                    document.getElementById('doctrWords').textContent = data.doctr.word_count;
                    document.getElementById('doctrLines').textContent = data.doctr.line_count;
                    document.getElementById('doctrConfidence').textContent = data.doctr.avg_confidence + '%';
                    updateFeatureTag('doctrUppercase', data.doctr.has_uppercase);
                    updateFeatureTag('doctrNumbers', data.doctr.has_numbers);
                    updateFeatureTag('doctrSymbols', data.doctr.has_symbols);

                    // Set Tesseract analysis
                    document.getElementById('tesseractTime').textContent = data.tesseract.processing_time_ms + ' ms';
                    document.getElementById('tesseractWords').textContent = data.tesseract.word_count;
                    document.getElementById('tesseractLines').textContent = data.tesseract.line_count;
                    document.getElementById('tesseractConfidence').textContent = data.tesseract.avg_confidence + '%';
                    updateFeatureTag('tesseractUppercase', data.tesseract.has_uppercase);
                    updateFeatureTag('tesseractNumbers', data.tesseract.has_numbers);
                    updateFeatureTag('tesseractSymbols', data.tesseract.has_symbols);

                    // Set PaddleOCR analysis
                    document.getElementById('paddleocrTime').textContent = data.paddleocr.processing_time_ms + ' ms';
                    document.getElementById('paddleocrWords').textContent = data.paddleocr.word_count;
                    document.getElementById('paddleocrLines').textContent = data.paddleocr.line_count;
                    document.getElementById('paddleocrConfidence').textContent = data.paddleocr.avg_confidence + '%';
                    updateFeatureTag('paddleocrUppercase', data.paddleocr.has_uppercase);
                    updateFeatureTag('paddleocrNumbers', data.paddleocr.has_numbers);
                    updateFeatureTag('paddleocrSymbols', data.paddleocr.has_symbols);

                    // Update comparison chart
                    updateComparisonChart(data);

                    resultsSection.style.display = 'block';
                }
            })
            .catch(error => {
                loading.style.display = 'none';
                showError('An error occurred while processing the image.');
                console.error('Error:', error);
            });
        }

        function copyText(elementId) {
            const text = document.getElementById(elementId).textContent;
            navigator.clipboard.writeText(text).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }

        function showError(message) {
            errorText.textContent = message;
            errorMessage.style.display = 'block';
        }

        function updateFeatureTag(elementId, detected) {
            const element = document.getElementById(elementId);
            if (detected) {
                element.classList.add('detected');
                element.classList.remove('not-detected');
            } else {
                element.classList.add('not-detected');
                element.classList.remove('detected');
            }
        }

        function resetUI() {
            uploadArea.style.display = 'block';
            previewSection.style.display = 'none';
            resultsSection.style.display = 'none';
            errorMessage.style.display = 'none';
            loading.style.display = 'none';
            fileInput.value = '';
            imagePreview.src = '';
        }

        // Smooth Line Chart with Canvas
        class SmoothLineChart {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.animationProgress = 0;
                this.data = null;
                this.dpr = window.devicePixelRatio || 1;
                this.colors = {
                    keras: { line: '#f78166', fill: 'rgba(247, 129, 102, 0.2)' },
                    doctr: { line: '#3fb950', fill: 'rgba(63, 185, 80, 0.2)' },
                    tesseract: { line: '#58a6ff', fill: 'rgba(88, 166, 255, 0.2)' },
                    paddleocr: { line: '#f778ba', fill: 'rgba(247, 120, 186, 0.2)' }
                };
                this.metrics = ['Speed', 'Words', 'Lines', 'Chars', 'Confidence'];
                this.width = 800;
                this.height = 350;
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();

                // Only resize if container has width
                if (rect.width > 0) {
                    this.width = rect.width;
                    this.height = 350;

                    // Set canvas size with device pixel ratio for sharp rendering
                    this.canvas.width = this.width * this.dpr;
                    this.canvas.height = this.height * this.dpr;
                    this.canvas.style.width = this.width + 'px';
                    this.canvas.style.height = this.height + 'px';

                    // Reset and scale context
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.scale(this.dpr, this.dpr);

                    if (this.data) this.draw(1);
                }
            }

            setData(ocrData) {
                // Resize first to ensure canvas is properly sized (chart section may have just become visible)
                this.resize();

                const maxTime = Math.max(
                    ocrData.keras_ocr.processing_time_ms,
                    ocrData.doctr.processing_time_ms,
                    ocrData.tesseract.processing_time_ms,
                    ocrData.paddleocr.processing_time_ms,
                    1
                );
                const maxWords = Math.max(
                    ocrData.keras_ocr.word_count,
                    ocrData.doctr.word_count,
                    ocrData.tesseract.word_count,
                    ocrData.paddleocr.word_count,
                    1
                );
                const maxLines = Math.max(
                    ocrData.keras_ocr.line_count,
                    ocrData.doctr.line_count,
                    ocrData.tesseract.line_count,
                    ocrData.paddleocr.line_count,
                    1
                );
                const maxChars = Math.max(
                    ocrData.keras_ocr.char_count,
                    ocrData.doctr.char_count,
                    ocrData.tesseract.char_count,
                    ocrData.paddleocr.char_count,
                    1
                );

                // Normalize all values to 0-100 scale
                this.data = {
                    keras: [
                        100 - (ocrData.keras_ocr.processing_time_ms / maxTime * 100), // Speed (inverted)
                        (ocrData.keras_ocr.word_count / maxWords * 100),
                        (ocrData.keras_ocr.line_count / maxLines * 100),
                        (ocrData.keras_ocr.char_count / maxChars * 100),
                        0 // No confidence for keras
                    ],
                    doctr: [
                        100 - (ocrData.doctr.processing_time_ms / maxTime * 100),
                        (ocrData.doctr.word_count / maxWords * 100),
                        (ocrData.doctr.line_count / maxLines * 100),
                        (ocrData.doctr.char_count / maxChars * 100),
                        ocrData.doctr.avg_confidence || 0
                    ],
                    tesseract: [
                        100 - (ocrData.tesseract.processing_time_ms / maxTime * 100),
                        (ocrData.tesseract.word_count / maxWords * 100),
                        (ocrData.tesseract.line_count / maxLines * 100),
                        (ocrData.tesseract.char_count / maxChars * 100),
                        ocrData.tesseract.avg_confidence || 0
                    ],
                    paddleocr: [
                        100 - (ocrData.paddleocr.processing_time_ms / maxTime * 100),
                        (ocrData.paddleocr.word_count / maxWords * 100),
                        (ocrData.paddleocr.line_count / maxLines * 100),
                        (ocrData.paddleocr.char_count / maxChars * 100),
                        ocrData.paddleocr.avg_confidence || 0
                    ]
                };

                this.rawData = ocrData;
                this.animate();
            }

            animate() {
                this.animationProgress = 0;
                const duration = 1500;
                const startTime = performance.now();

                const step = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    this.animationProgress = Math.min(elapsed / duration, 1);
                    // Easing function for smooth animation
                    const eased = 1 - Math.pow(1 - this.animationProgress, 3);
                    this.draw(eased);

                    if (this.animationProgress < 1) {
                        requestAnimationFrame(step);
                    }
                };

                requestAnimationFrame(step);
            }

            draw(progress) {
                const ctx = this.ctx;
                const padding = { top: 40, right: 30, bottom: 50, left: 60 };
                const chartWidth = this.width - padding.left - padding.right;
                const chartHeight = this.height - padding.top - padding.bottom;

                // Clear canvas
                ctx.clearRect(0, 0, this.width, this.height);

                // Background
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, this.width, this.height);

                // Grid lines
                ctx.strokeStyle = '#21262d';
                ctx.lineWidth = 1;

                // Horizontal grid lines
                for (let i = 0; i <= 5; i++) {
                    const y = padding.top + (chartHeight / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(this.width - padding.right, y);
                    ctx.stroke();

                    // Y-axis labels
                    ctx.fillStyle = '#6e7681';
                    ctx.font = '11px Inter, sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText((100 - i * 20) + '', padding.left - 10, y + 4);
                }

                // X-axis labels
                const xStep = chartWidth / (this.metrics.length - 1);
                ctx.textAlign = 'center';
                this.metrics.forEach((metric, i) => {
                    const x = padding.left + i * xStep;
                    ctx.fillStyle = '#8b949e';
                    ctx.font = '12px Inter, sans-serif';
                    ctx.fillText(metric, x, this.height - padding.bottom + 25);

                    // Vertical grid lines
                    ctx.strokeStyle = '#21262d';
                    ctx.beginPath();
                    ctx.moveTo(x, padding.top);
                    ctx.lineTo(x, this.height - padding.bottom);
                    ctx.stroke();
                });

                if (!this.data) return;

                // Draw lines for each engine
                const engines = ['keras', 'doctr', 'tesseract', 'paddleocr'];

                engines.forEach(engine => {
                    const values = this.data[engine];
                    const color = this.colors[engine];
                    const points = [];

                    // Calculate points
                    values.forEach((value, i) => {
                        const x = padding.left + i * xStep;
                        const animatedValue = value * progress;
                        const y = padding.top + chartHeight - (animatedValue / 100 * chartHeight);
                        points.push({ x, y, value: animatedValue });
                    });

                    // Draw filled area with gradient
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, this.height - padding.bottom);

                    // Smooth curve using bezier
                    for (let i = 0; i < points.length; i++) {
                        if (i === 0) {
                            ctx.lineTo(points[i].x, points[i].y);
                        } else {
                            const prev = points[i - 1];
                            const curr = points[i];
                            const cpx = (prev.x + curr.x) / 2;
                            ctx.bezierCurveTo(cpx, prev.y, cpx, curr.y, curr.x, curr.y);
                        }
                    }

                    ctx.lineTo(points[points.length - 1].x, this.height - padding.bottom);
                    ctx.closePath();

                    const gradient = ctx.createLinearGradient(0, padding.top, 0, this.height - padding.bottom);
                    gradient.addColorStop(0, color.fill);
                    gradient.addColorStop(1, 'rgba(13, 17, 23, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // Draw smooth line
                    ctx.beginPath();
                    ctx.strokeStyle = color.line;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    for (let i = 0; i < points.length; i++) {
                        if (i === 0) {
                            ctx.moveTo(points[i].x, points[i].y);
                        } else {
                            const prev = points[i - 1];
                            const curr = points[i];
                            const cpx = (prev.x + curr.x) / 2;
                            ctx.bezierCurveTo(cpx, prev.y, cpx, curr.y, curr.x, curr.y);
                        }
                    }
                    ctx.stroke();

                    // Draw points
                    points.forEach((point, i) => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                        ctx.fillStyle = '#0d1117';
                        ctx.fill();
                        ctx.strokeStyle = color.line;
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        // Inner dot
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                        ctx.fillStyle = color.line;
                        ctx.fill();
                    });
                });

                // Title
                ctx.fillStyle = '#f0f6fc';
                ctx.font = 'bold 14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('OCR Engine Performance Comparison', this.width / 2, 20);
            }
        }

        // Initialize chart
        let comparisonChart = null;

        function updateComparisonChart(data) {
            // Use setTimeout to ensure the results section is visible and has dimensions
            setTimeout(() => {
                if (!comparisonChart) {
                    comparisonChart = new SmoothLineChart('comparisonChart');
                }
                comparisonChart.setData(data);
            }, 100);
        }
    </script>
</body>
</html>
